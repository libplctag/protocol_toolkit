// Modbus Protocol Definition Language Example
// Generated from /src/examples/modbus/lib/include/modbus.h

//=============================================================================
// BASIC TYPES AND CONSTANTS
//=============================================================================

// Basic types with Modbus byte ordering (big-endian)
def u8 = { type: u8 }
def u16_be = { type: u16, byte_order: [1, 0] }

// Semantic types for clarity
def modbus_address = u16_be
def modbus_quantity = u16_be
def modbus_register = u16_be

// Array types (generate PTK_ARRAY_DECLARE statements)
def modbus_register_array = modbus_register[]

// Bit arrays with u8 container type (matches Modbus wire format)
def modbus_bit_array = { type: bit[], container_type: u8 }

// Modbus function codes
def MODBUS_FC_READ_COILS = { type: u8, const: 0x01 }
def MODBUS_FC_READ_DISCRETE_INPUTS = { type: u8, const: 0x02 }
def MODBUS_FC_READ_HOLDING_REGISTERS = { type: u8, const: 0x03 }
def MODBUS_FC_READ_INPUT_REGISTERS = { type: u8, const: 0x04 }
def MODBUS_FC_WRITE_SINGLE_COIL = { type: u8, const: 0x05 }
def MODBUS_FC_WRITE_SINGLE_REGISTER = { type: u8, const: 0x06 }
def MODBUS_FC_WRITE_MULTIPLE_COILS = { type: u8, const: 0x0F }
def MODBUS_FC_WRITE_MULTIPLE_REGISTERS = { type: u8, const: 0x10 }

// Exception codes
def MODBUS_EXCEPTION_ILLEGAL_FUNCTION = { type: u8, const: 0x01 }
def MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS = { type: u8, const: 0x02 }
def MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE = { type: u8, const: 0x03 }
def MODBUS_EXCEPTION_SLAVE_DEVICE_FAILURE = { type: u8, const: 0x04 }

// Special values for write single coil
def MODBUS_COIL_OFF = { type: u16_be, const: 0x0000 }
def MODBUS_COIL_ON = { type: u16_be, const: 0xFF00 }

//=============================================================================
// FUNCTION CODE 0x01 - READ COILS
//=============================================================================

def modbus_read_coils_req = {
    type: message,
    match: (function_code == MODBUS_FC_READ_COILS),
    fields: [
        function_code: u8,
        starting_address: modbus_address,
        quantity_of_coils: modbus_quantity
    ]
}

def modbus_read_coils_resp = {
    type: message,
    match: (function_code == MODBUS_FC_READ_COILS),
    response_to: modbus_read_coils_req,
    fields: [
        function_code: u8,
        byte_count: {
            type: u8,
            encode: (coil_status.container_count)
        },
        coil_status: {
            type: modbus_bit_array[],
            length: {
                decode: (byte_count)
            }
        }
    ]
}

//=============================================================================
// FUNCTION CODE 0x02 - READ DISCRETE INPUTS
//=============================================================================

def modbus_read_discrete_inputs_req = {
    type: message,
    match: (function_code == MODBUS_FC_READ_DISCRETE_INPUTS),
    fields: [
        function_code: u8,
        starting_address: modbus_address,
        quantity_of_inputs: modbus_quantity
    ]
}

def modbus_read_discrete_inputs_resp = {
    type: message,
    match: (function_code == MODBUS_FC_READ_DISCRETE_INPUTS),
    response_to: modbus_read_discrete_inputs_req,
    fields: [
        function_code: u8,
        byte_count: {
            type: u8,
            encode: (input_status.container_count)
        },
        input_status: {
            type: modbus_bit_array[],
            length: {
                decode: (byte_count)
            }
        }
    ]
}

//=============================================================================
// FUNCTION CODE 0x03 - READ HOLDING REGISTERS
//=============================================================================

def modbus_read_holding_registers_req = {
    type: message,
    match: (function_code == MODBUS_FC_READ_HOLDING_REGISTERS),
    fields: [
        function_code: u8,
        starting_address: modbus_address,
        quantity_of_registers: modbus_quantity
    ]
}

def modbus_read_holding_registers_resp = {
    type: message,
    match: (function_code == MODBUS_FC_READ_HOLDING_REGISTERS),
    response_to: modbus_read_holding_registers_req,
    fields: [
        function_code: u8,
        byte_count: {
            type: u8,
            encode: (register_values.count * 2)
        },
        register_values: {
            type: modbus_register_array[],
            length: {
                decode: (byte_count / 2)
            }
        }
    ]
}

//=============================================================================
// FUNCTION CODE 0x04 - READ INPUT REGISTERS
//=============================================================================

def modbus_read_input_registers_req = {
    type: message,
    match: (function_code == MODBUS_FC_READ_INPUT_REGISTERS),
    fields: [
        function_code: u8,
        starting_address: modbus_address,
        quantity_of_registers: modbus_quantity
    ]
}

def modbus_read_input_registers_resp = {
    type: message,
    match: (function_code == MODBUS_FC_READ_INPUT_REGISTERS),
    response_to: modbus_read_input_registers_req,
    fields: [
        function_code: u8,
        byte_count: {
            type: u8,
            encode: (register_values.count * 2)
        },
        register_values: {
            type: modbus_register_array[],
            length: {
                decode: (byte_count / 2)
            }
        }
    ]
}

//=============================================================================
// FUNCTION CODE 0x05 - WRITE SINGLE COIL
//=============================================================================

def modbus_write_single_coil_req = {
    type: message,
    match: (function_code == MODBUS_FC_WRITE_SINGLE_COIL),
    fields: [
        function_code: u8,
        output_address: modbus_address,
        output_value: u16_be  // 0x0000 = OFF, 0xFF00 = ON
    ]
}

def modbus_write_single_coil_resp = {
    type: message,
    match: (function_code == MODBUS_FC_WRITE_SINGLE_COIL),
    response_to: modbus_write_single_coil_req,
    fields: [
        function_code: u8,
        output_address: modbus_address,  // Echo of request
        output_value: u16_be             // Echo of request
    ]
}

//=============================================================================
// FUNCTION CODE 0x06 - WRITE SINGLE REGISTER
//=============================================================================

def modbus_write_single_register_req = {
    type: message,
    match: (function_code == MODBUS_FC_WRITE_SINGLE_REGISTER),
    fields: [
        function_code: u8,
        register_address: modbus_address,
        register_value: modbus_register
    ]
}

def modbus_write_single_register_resp = {
    type: message,
    match: (function_code == MODBUS_FC_WRITE_SINGLE_REGISTER),
    response_to: modbus_write_single_register_req,
    fields: [
        function_code: u8,
        register_address: modbus_address,  // Echo of request
        register_value: modbus_register    // Echo of request
    ]
}

//=============================================================================
// FUNCTION CODE 0x0F - WRITE MULTIPLE COILS
//=============================================================================

def modbus_write_multiple_coils_req = {
    type: message,
    match: (function_code == MODBUS_FC_WRITE_MULTIPLE_COILS),
    fields: [
        function_code: u8,
        starting_address: modbus_address,
        quantity_of_outputs: {
            type: modbus_quantity,
            encode: (output_values.bit_count)
        },
        byte_count: {
            type: u8,
            encode: (output_values.container_count)
        },
        output_values: {
            type: modbus_bit_array[],
            length: {
                decode: (byte_count)
            }
        }
    ]
}

def modbus_write_multiple_coils_resp = {
    type: message,
    match: (function_code == MODBUS_FC_WRITE_MULTIPLE_COILS),
    response_to: modbus_write_multiple_coils_req,
    fields: [
        function_code: u8,
        starting_address: modbus_address,           // Echo of request
        quantity_of_outputs: modbus_quantity       // Echo of request (bit count)
    ]
}

//=============================================================================
// FUNCTION CODE 0x10 - WRITE MULTIPLE REGISTERS
//=============================================================================

def modbus_write_multiple_registers_req = {
    type: message,
    match: (function_code == MODBUS_FC_WRITE_MULTIPLE_REGISTERS),
    fields: [
        function_code: u8,
        starting_address: modbus_address,
        quantity_of_registers: {
            type: modbus_quantity,
            encode: (register_values.count)
        },
        byte_count: {
            type: u8,
            encode: (register_values.count * 2)
        },
        register_values: {
            type: modbus_register_array[],
            length: {
                decode: (byte_count / 2)
            }
        }
    ]
}

def modbus_write_multiple_registers_resp = {
    type: message,
    match: (function_code == MODBUS_FC_WRITE_MULTIPLE_REGISTERS),
    response_to: modbus_write_multiple_registers_req,
    fields: [
        function_code: u8,
        starting_address: modbus_address,           // Echo of request
        quantity_of_registers: modbus_quantity     // Echo of request (register count)
    ]
}

//=============================================================================
// EXCEPTION RESPONSE
//=============================================================================

def modbus_exception_resp = {
    type: message,
    match: (exception_function_code >= 0x81 && exception_function_code <= 0x90),
    response_to: ALL,
    fields: [
        exception_function_code: u8,  // Original function code + 0x80
        exception_code: u8            // Error code (1-4, etc.)
    ]
}

//=============================================================================
// ROOT PDU UNION
//=============================================================================

def modbus_pdu = {
    type: message,
    fields: [
        pdu_data: [
            modbus_read_coils_req,
            modbus_read_coils_resp,
            modbus_read_discrete_inputs_req,
            modbus_read_discrete_inputs_resp,
            modbus_read_holding_registers_req,
            modbus_read_holding_registers_resp,
            modbus_read_input_registers_req,
            modbus_read_input_registers_resp,
            modbus_write_single_coil_req,
            modbus_write_single_coil_resp,
            modbus_write_single_register_req,
            modbus_write_single_register_resp,
            modbus_write_multiple_coils_req,
            modbus_write_multiple_coils_resp,
            modbus_write_multiple_registers_req,
            modbus_write_multiple_registers_resp,
            modbus_exception_resp
        ]
    ]
}