#ifndef PTK_EVENT_LOOP_H
#define PTK_EVENT_LOOP_H

#include <stdint.h>
#include <stdbool.h>
#include <sys/event.h>
#include <sys/time.h>

// Platform-specific constants for macOS
#define PTK_MAX_KEVENTS 64
#define PTK_MAX_TIMERS_PER_LOOP 32

// Error handling
typedef enum {
    PTK_SUCCESS,
    PTK_ERR_INVALID_ARG,
    PTK_ERR_OUT_OF_BOUNDS,
    PTK_ERR_TRANSITION_EXISTS,
    PTK_ERR_SOCKET_FAILURE,
    PTK_ERR_UNKNOWN
} ptk_error_t;

// Time in milliseconds
typedef uint32_t ptk_time_ms;

// Forward declarations
struct ptk_state_machine;
struct ptk_transition_table;
struct ptk_event_source;

// Action function signature for state transitions
typedef void (*ptk_action_func)(struct ptk_state_machine *sm, struct ptk_event_source *es, ptk_time_ms now_ms);

// Transition definition
typedef struct {
    int initial_state;                  // Current state
    int event_id;                       // Event triggering the transition
    int next_state;                     // Next state after the transition
    struct ptk_state_machine *next_sm;  // Optional: Transition to another state machine
    ptk_action_func action;             // Action called during the transition
} ptk_transition_t;

// Transition table entity
typedef struct ptk_transition_table {
    ptk_transition_t *transitions;  // Array of transitions
    uint32_t transition_count;      // Current number of transitions
    uint32_t max_transitions;       // Maximum allowed transitions
} ptk_transition_table_t;

// State machine entity
typedef struct ptk_state_machine {
    int current_state;                  // Current state of the state machine
    ptk_transition_table_t **tables;    // Array of transition tables (hierarchical sub-states)
    uint32_t table_count;               // Number of attached transition tables
    uint32_t max_tables;                // Maximum number of transition tables
    struct ptk_event_source **sources;  // Array of event sources attached to this state machine
    uint32_t source_count;              // Number of attached event sources
    uint32_t max_sources;               // Maximum number of event sources
    struct ptk_loop *loop;              // Associated event loop
    void *user_data;                    // User-defined context pointer
} ptk_state_machine_t;

// Event source entity
typedef struct ptk_event_source {
    int event_id;             // Event ID generated by this source
    ptk_time_ms interval_ms;  // For timers: interval in milliseconds
    bool periodic;            // For timers: true if periodic, false for one-shot
    void *user_data;          // User-defined context pointer

    // Platform-specific data for macOS kevent
    struct {
        enum { PTK_ES_TIMER, PTK_ES_SOCKET, PTK_ES_USER } type;
        uintptr_t ident;                     // kevent identifier (fd for sockets, timer_id for timers)
        bool active;                         // Whether this event source is currently registered
        struct timespec next_fire;           // For timers: next fire time (absolute)
        struct ptk_state_machine *owner_sm;  // State machine that owns this event source
    } macos;
} ptk_event_source_t;

// Socket types
typedef enum { PTK_SOCKET_TCP, PTK_SOCKET_UDP } ptk_socket_type_t;

// TCP/UDP socket entity
typedef struct {
    ptk_socket_type_t type;
    int socket_fd;
    void *user_data;  // User-defined context pointer

    // Platform-specific data for macOS
    struct {
        bool nonblocking;                  // Socket is in non-blocking mode
        bool registered_read;              // Read events registered with kevent
        bool registered_write;             // Write events registered with kevent
        ptk_event_source_t *read_source;   // Associated read event source
        ptk_event_source_t *write_source;  // Associated write event source
    } macos;
} ptk_socket_t;

// Event loop entity
typedef struct ptk_loop {
    struct ptk_state_machine *current_sm;  // Active state machine
    void *platform_data;                   // Platform-specific data (hidden from user)

    // Platform-specific data for macOS kevent
    struct {
        int kqueue_fd;                          // kqueue file descriptor
        struct kevent events[PTK_MAX_KEVENTS];  // Event buffer for kevent()
        bool running;                           // Loop is running
        uint32_t next_timer_id;                 // Next available timer ID

        // Timer management (static allocation)
        struct {
            ptk_event_source_t *source;  // Associated event source
            bool in_use;                 // Timer slot is active
        } timers[PTK_MAX_TIMERS_PER_LOOP];
    } macos;
} ptk_loop_t;

// Transition table API
ptk_error_t ptk_tt_init(ptk_transition_table_t *tt, ptk_transition_t *transitions, uint32_t max_transitions);

ptk_error_t ptk_tt_add_transition(ptk_transition_table_t *tt, int initial_state, int event_id, int next_state,
                                  ptk_state_machine_t *next_sm, ptk_action_func action);

// State machine API
ptk_error_t ptk_sm_init(ptk_state_machine_t *sm, ptk_transition_table_t **tables, uint32_t max_tables,
                        ptk_event_source_t **sources, uint32_t max_sources, struct ptk_loop *loop, void *user_data);

ptk_error_t ptk_sm_attach_table(ptk_state_machine_t *sm, ptk_transition_table_t *tt);

ptk_error_t ptk_sm_attach_event_source(ptk_state_machine_t *sm, ptk_event_source_t *es);

ptk_error_t ptk_sm_handle_event(ptk_state_machine_t *sm, int event_id, ptk_event_source_t *es, ptk_time_ms now_ms);

ptk_error_t ptk_sm_add_to_loop(ptk_loop_t *loop, ptk_state_machine_t *sm);

// Event source API
ptk_error_t ptk_es_init_timer(ptk_event_source_t *es, int event_id, ptk_time_ms interval_ms, bool periodic, void *user_data);

ptk_error_t ptk_es_init_user_event(ptk_event_source_t *es, int event_id, void *user_data);

// Event loop API
ptk_error_t ptk_loop_init(ptk_loop_t *loop, ptk_state_machine_t *initial_sm);

void ptk_loop_run(ptk_loop_t *loop);
void ptk_loop_stop(ptk_loop_t *loop);

// TCP/UDP Socket API
ptk_error_t ptk_socket_open_tcp_client(ptk_socket_t *socket, const char *remote_ip, uint16_t remote_port, void *user_data);

ptk_error_t ptk_socket_open_tcp_server(ptk_socket_t *socket, const char *local_ip, uint16_t local_port, void *user_data);

ptk_error_t ptk_socket_open_udp(ptk_socket_t *socket, const char *local_ip, uint16_t local_port, void *user_data);

ptk_error_t ptk_socket_accept(ptk_socket_t *server_socket, ptk_socket_t *client_socket);

ptk_error_t ptk_socket_send(ptk_socket_t *socket, const void *data, size_t data_len);

ptk_error_t ptk_socket_receive(ptk_socket_t *socket, void *buffer, size_t buffer_len, size_t *received_len);

ptk_error_t ptk_socket_receive_from(ptk_socket_t *socket, void *buffer, size_t buffer_len, size_t *received_len, char *sender_ip,
                                    uint16_t *sender_port);

ptk_error_t ptk_socket_send_to(ptk_socket_t *socket, const char *target_ip, uint16_t target_port, const void *data,
                               size_t data_len);

ptk_error_t ptk_socket_attach_multicast(ptk_socket_t *socket, const char *multicast_group, const char *local_ip);

ptk_error_t ptk_socket_detach_multicast(ptk_socket_t *socket, const char *multicast_group, const char *local_ip);

// Socket event registration
ptk_error_t ptk_socket_register_events(ptk_loop_t *loop, ptk_socket_t *socket, ptk_event_source_t *read_source,
                                       ptk_event_source_t *write_source);

ptk_error_t ptk_socket_unregister_events(ptk_loop_t *loop, ptk_socket_t *socket);

#endif  // PTK_EVENT_LOOP_H
