#!/bin/bash

# Protocol Toolkit Version Manager
# Manages semantic versioning for the project

set -e

VERSION_FILE="VERSION"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
VERSION_FILE_PATH="$PROJECT_ROOT/$VERSION_FILE"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to read current version
get_current_version() {
    if [ -f "$VERSION_FILE_PATH" ]; then
        cat "$VERSION_FILE_PATH"
    else
        echo "1.0.0"
    fi
}

# Function to parse version into components
parse_version() {
    local version="$1"
    local major minor patch
    
    # Use parameter expansion to split version
    major="${version%%.*}"
    minor="${version#*.}"
    minor="${minor%.*}"
    patch="${version##*.}"
    
    echo "$major $minor $patch"
}

# Function to increment patch version
increment_patch() {
    local current_version="$1"
    local components
    local major minor patch
    
    components=($(parse_version "$current_version"))
    major="${components[0]}"
    minor="${components[1]}"
    patch="${components[2]}"
    
    patch=$((patch + 1))
    
    echo "$major.$minor.$patch"
}

# Function to set version with patch reset
set_version_reset_patch() {
    local major="$1"
    local minor="$2"
    local new_version="$major.$minor.0"
    
    echo "$new_version" > "$VERSION_FILE_PATH"
    print_success "Version set to $new_version (patch reset to 0)"
}

# Function to increment patch and write to file
increment_patch_version() {
    local current_version
    local new_version
    
    current_version=$(get_current_version)
    new_version=$(increment_patch "$current_version")
    
    echo "$new_version" > "$VERSION_FILE_PATH"
    print_success "Version incremented from $current_version to $new_version"
    echo "$new_version"
}

# Function to validate version format
validate_version() {
    local version="$1"
    
    if [[ ! "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        print_error "Invalid version format: $version"
        print_error "Expected format: major.minor.patch (e.g., 1.2.3)"
        return 1
    fi
    
    return 0
}

# Function to update version in CMakeLists.txt
update_cmake_version() {
    local version="$1"
    local cmake_file="$PROJECT_ROOT/CMakeLists.txt"
    
    if [ -f "$cmake_file" ]; then
        # Update project version in CMakeLists.txt
        sed -i.bak "s/project(protocol_toolkit)/project(protocol_toolkit VERSION $version)/" "$cmake_file"
        
        # Also update any VERSION lines
        sed -i.bak "s/VERSION [0-9]\+\.[0-9]\+\.[0-9]\+/VERSION $version/" "$cmake_file"
        
        rm -f "$cmake_file.bak"
        print_info "Updated CMakeLists.txt with version $version"
    fi
}

# Function to update version in package files
update_package_version() {
    local version="$1"
    local cmake_config="$PROJECT_ROOT/cmake/PTKConfig.cmake.in"
    
    if [ -f "$cmake_config" ]; then
        sed -i.bak "s/@PROJECT_VERSION@/$version/g" "$cmake_config"
        rm -f "$cmake_config.bak"
        print_info "Updated package config with version $version"
    fi
}

# Function to create version header file
create_version_header() {
    local version="$1"
    local components
    local major minor patch
    
    components=($(parse_version "$version"))
    major="${components[0]}"
    minor="${components[1]}"
    patch="${components[2]}"
    
    local header_file="$PROJECT_ROOT/src/include/ptk_version.h"
    
    cat > "$header_file" << EOF
#pragma once

/**
 * @file ptk_version.h
 * @brief Protocol Toolkit version information
 * 
 * This file is automatically generated by the version manager.
 * Do not edit manually.
 */

#define PTK_VERSION_MAJOR $major
#define PTK_VERSION_MINOR $minor
#define PTK_VERSION_PATCH $patch

#define PTK_VERSION_STRING "$version"

#define PTK_VERSION_ENCODE(major, minor, patch) \\
    (((major) << 16) | ((minor) << 8) | (patch))

#define PTK_VERSION_CURRENT \\
    PTK_VERSION_ENCODE(PTK_VERSION_MAJOR, PTK_VERSION_MINOR, PTK_VERSION_PATCH)

#define PTK_VERSION_CHECK(major, minor, patch) \\
    (PTK_VERSION_CURRENT >= PTK_VERSION_ENCODE(major, minor, patch))
EOF
    
    print_info "Created version header: $header_file"
}

# Function to show usage
show_usage() {
    echo "Usage: $0 <command> [arguments]"
    echo ""
    echo "Commands:"
    echo "  get                          Get current version"
    echo "  increment-patch              Increment patch version"
    echo "  set <major.minor.patch>      Set specific version"
    echo "  set-major-minor <major> <minor>  Set major.minor with patch=0"
    echo "  validate <version>           Validate version format"
    echo "  update-files                 Update all version references in project files"
    echo "  create-header               Create version header file"
    echo ""
    echo "Examples:"
    echo "  $0 get                      # Shows current version"
    echo "  $0 increment-patch          # 1.0.0 -> 1.0.1"
    echo "  $0 set 2.1.0               # Set to 2.1.0"
    echo "  $0 set-major-minor 2 1     # Set to 2.1.0"
    echo "  $0 update-files            # Update CMakeLists.txt, headers, etc."
}

# Main command processing
main() {
    local command="$1"
    
    case "$command" in
        "get")
            get_current_version
            ;;
        "increment-patch")
            increment_patch_version
            ;;
        "set")
            if [ $# -ne 2 ]; then
                print_error "Usage: $0 set <major.minor.patch>"
                exit 1
            fi
            
            local new_version="$2"
            if validate_version "$new_version"; then
                echo "$new_version" > "$VERSION_FILE_PATH"
                print_success "Version set to $new_version"
            else
                exit 1
            fi
            ;;
        "set-major-minor")
            if [ $# -ne 3 ]; then
                print_error "Usage: $0 set-major-minor <major> <minor>"
                exit 1
            fi
            
            local major="$2"
            local minor="$3"
            
            if [[ ! "$major" =~ ^[0-9]+$ ]] || [[ ! "$minor" =~ ^[0-9]+$ ]]; then
                print_error "Major and minor versions must be numbers"
                exit 1
            fi
            
            set_version_reset_patch "$major" "$minor"
            ;;
        "validate")
            if [ $# -ne 2 ]; then
                print_error "Usage: $0 validate <version>"
                exit 1
            fi
            
            validate_version "$2"
            ;;
        "update-files")
            local current_version
            current_version=$(get_current_version)
            update_cmake_version "$current_version"
            update_package_version "$current_version"
            create_version_header "$current_version"
            print_success "Updated all project files with version $current_version"
            ;;
        "create-header")
            local current_version
            current_version=$(get_current_version)
            create_version_header "$current_version"
            ;;
        *)
            show_usage
            exit 1
            ;;
    esac
}

# Run main function
main "$@"