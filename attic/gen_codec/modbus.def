#define MAX_PAYLOAD 253

// Modbus function codes
#define MODBUS_READ_COILS 0x01
#define MODBUS_READ_DISCRETE_INPUTS 0x02
#define MODBUS_READ_HOLDING_REGISTERS 0x03
#define MODBUS_READ_INPUT_REGISTERS 0x04
#define MODBUS_WRITE_SINGLE_COIL 0x05
#define MODBUS_WRITE_SINGLE_REGISTER 0x06
#define MODBUS_WRITE_MULTIPLE_COILS 0x0F
#define MODBUS_WRITE_MULTIPLE_REGISTERS 0x10

// Simple struct with fixed fields
struct mbap {
    codec_u16_be transaction_id;    // Transaction ID
    codec_u16_be protocol_id;       /* Protocol identifier */
    codec_u16_be length;            // Length of following bytes
    codec_u8 unit_id;               // Unit identifier
};

// Read Holding Registers (0x03)
struct read_holding_registers_req {
    codec_u8     function_code;       // Always 0x03
    codec_u16_be starting_address;
    codec_u16_be quantity_of_registers;
};

struct read_holding_registers_resp {
    codec_u8     function_code;       // Always 0x03
    codec_u8     byte_count;
    codec_u16_be *reg_values;         // User provides function.
};

// Read Input Registers (0x04)
struct read_input_registers_req {
    codec_u8     function_code;       // Always 0x04
    codec_u16_be starting_address;
    codec_u16_be quantity_of_registers;
};

struct read_input_registers_resp {
    codec_u8     function_code;       // Always 0x04
    codec_u8     byte_count;
    codec_u16_be *reg_values;         // User provides function.
};

// Read Coils (0x01)
struct read_coils_req {
    codec_u8     function_code;       // Always 0x01
    codec_u16_be starting_address;
    codec_u16_be quantity_of_coils;
};

struct read_coils_resp {
    codec_u8     function_code;       // Always 0x01
    codec_u8     byte_count;
    codec_u8     *coil_status;        // User provides function.
};

// Read Discrete Inputs (0x02)
struct read_discrete_inputs_req {
    codec_u8     function_code;       // Always 0x02
    codec_u16_be starting_address;
    codec_u16_be quantity_of_inputs;
};

struct read_discrete_inputs_resp {
    codec_u8     function_code;       // Always 0x02
    codec_u8     byte_count;
    codec_u8     *input_status;       // User provides function.
};

// Write Single Coil (0x05)
struct write_single_coil_req {
    codec_u8     function_code;       // Always 0x05
    codec_u16_be output_address;
    codec_u16_be output_value;        // 0x0000 or 0xFF00
};

struct write_single_coil_resp {
    codec_u8     function_code;       // Always 0x05
    codec_u16_be output_address;
    codec_u16_be output_value;        // Echo of request
};

// Write Single Register (0x06)
struct write_single_register_req {
    codec_u8     function_code;       // Always 0x06
    codec_u16_be register_address;
    codec_u16_be register_value;
};

struct write_single_register_resp {
    codec_u8     function_code;       // Always 0x06
    codec_u16_be register_address;
    codec_u16_be register_value;      // Echo of request
};

// Write Multiple Coils (0x0F)
struct write_multiple_coils_req {
    codec_u8     function_code;       // Always 0x0F
    codec_u16_be starting_address;
    codec_u16_be quantity_of_outputs;
    codec_u8     byte_count;
    codec_u8     *output_values;      // User provides function.
};

struct write_multiple_coils_resp {
    codec_u8     function_code;       // Always 0x0F
    codec_u16_be starting_address;
    codec_u16_be quantity_of_outputs;
};

// Write Multiple Registers (0x10)
struct write_multiple_registers_req {
    codec_u8     function_code;       // Always 0x10
    codec_u16_be starting_address;
    codec_u16_be quantity_of_registers;
    codec_u8     byte_count;
    codec_u16_be *register_values;    // User provides function.
};

struct write_multiple_registers_resp {
    codec_u8     function_code;       // Always 0x10
    codec_u16_be starting_address;
    codec_u16_be quantity_of_registers;
};
